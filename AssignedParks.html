<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Assigned Parks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="logo.png" type="image/png" />

  <!-- Core styles (same as ParksMowing) -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Sidebar styles (same as ParksMowing) -->
  <link rel="stylesheet" href="sidebar.css" />

  <style>
    :root{
      --ink:#0f172a; --muted:#e5e7eb; --card:#ffffff;
      --accent:#d11e2b; --accent-600:#b71a24;
      --soft:#f8fafc; --soft-2:#f1f5f9;
    }
    #map { height: 100vh; }

    /* Sidebar compact + brand */
    #sidebar{
      width: 340px;
      max-width: 86vw;
      background:#fff;
      border-right:1px solid var(--muted);
      box-shadow:0 8px 26px rgba(16,24,40,.08);
      overflow:auto;
    }
    #sidebar .sidebar-head{
      position: sticky; top:0; z-index: 5;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      color:#fff; font-weight:800;
      background: linear-gradient(90deg, var(--accent), #eb4550);
      border-bottom:1px solid rgba(255,255,255,.15);
    }
    #sidebar .sidebar-head img{ height:24px; width:auto; display:block }
    #sidebar .sidebar-head .title{ font-size:14px; letter-spacing:.3px }

    /* Buttons inside sidebar */
    #sidebar button{
      border:0; border-radius:10px; padding:8px 10px; font-weight:800; cursor:pointer; background: var(--accent); color:#fff;
    }
    #sidebar #toggle-all{ display:block; width:calc(100% - 24px); margin:10px 12px 8px; background:var(--accent); }
    #sidebar #toggle-all:hover{ background:var(--accent-600); }

    /* NEW: full-width utility buttons (Home/Admin etc.) */
    #sidebar .wide-btn{
      display:block; width:calc(100% - 24px); margin:8px 12px;
      background:#111827; color:#fff;
    }
    #sidebar .wide-btn:hover{ background:#0b1220; }

    /* Sidebar content spacing */
    #sidebar #sidebar-content{ padding:8px 12px 16px; }

    /* Groups / details look compact */
    #sidebar-content details{
      border:1px solid var(--muted); border-radius:12px; overflow:hidden;
      background:#fff; margin-bottom:8px;
    }
    #sidebar-content details > summary{
      list-style:none; cursor:pointer; user-select:none;
      padding:8px 10px; background:var(--soft-2);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:700; color:var(--ink);
    }
    #sidebar-content details[open] > summary{ background:#eef2f7; }

    /* Rows/items inside groups (support many structures) */
    #sidebar-content li,
    #sidebar-content .list-item,
    #sidebar-content .sidebar-row,
    #sidebar-content .item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px; border-top:1px solid #eef2f7; background:#fff;
      font-weight:600; color:#111827;
    }
    #sidebar-content li:first-child{ border-top:0; }

    /* Hide "assigned" badges/chips */
    #sidebar-content .mini-pill,
    #sidebar-content .badge,
    #sidebar-content .tag,
    #sidebar-content .status { display:none !important; }

    /* Our single Done button style */
    .bs-done-btn{
      appearance:none; border-radius:10px; border:1px solid #e2e8f0;
      background:#fff; color:#111827; padding:6px 10px; font-weight:800; cursor:pointer;
      margin-top:6px;
    }
    .bs-done-btn.done{
      background:#dcfce7; border-color:#bbf7d0; color:#065f46;
    }

    /* Banner above filtered list */
    .assign-banner{
      padding:8px 10px; margin:6px 0; border:1px solid #e2e8f0; background:#fff8f8;
      color:#7f1d1d; border-radius:8px; font-weight:700;
    }
  </style>
</head>
<body>

  <!-- Firebase + auth guard -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <script src="firebase-init.js"></script>
  <script src="auth-guard.js"></script>

  <!-- Sidebar toggle -->
  <button id="sidebar-toggle">☰</button>

  <!-- Sidebar -->
  <div id="sidebar">
    <div class="sidebar-head">
      <img src="logo.png" alt="Bayside" onerror="this.style.display='none'">
      <div class="title">Assigned Parks</div>
    </div>

    <!-- NEW: Return home button -->
    <button class="wide-btn" id="homeBtn" type="button" title="Back to Dashboard">Return home</button>

    <button id="toggle-all">Collapse All</button>
    <div id="sidebar-content"></div>

    <div style="padding:6px 0 14px">
      <button class="wide-btn" onclick="adminLogin()">Admin Login</button>
      <div id="admin-tools" style="display:none; margin-top:6px; padding:0 12px; display:grid; gap:6px">
        <button onclick="exportPDFCouncil()" style="background:#111827">PDF report for Council</button>
        <button onclick="exportPDFBayside()" style="background:#111827">PDF Report for Bayside</button>
        <button onclick="clearUserData()" style="background:#64748b">Clear All User Data</button>
        <button onclick="showToday()" style="background:#64748b">Show Completed Today</button>
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Try to suppress double-init from shared map bootstrap -->
  <script>window.BS_DISABLE_AUTO_INIT = true;</script>
  <script src="script.js"></script>
  <script src="sidebar.js"></script>
  <script>
    (function(){
      // Home button wiring
      document.getElementById('homeBtn')?.addEventListener('click', ()=> {
        // preserve a breadcrumb if you want (optional)
        try{ sessionStorage.setItem('bayside_prev', location.href); }catch(_){}
        location.href = 'index.html';
      });

      // Fallback init only if not already initialised by script.js
      try{
        var mapDiv = document.getElementById('map');
        if (typeof window.initParksMowingMap === 'function' && mapDiv && !mapDiv._leaflet_id){
          window.initParksMowingMap();
        }
      }catch(e){ /* cosmetic if it fails */ }
    })();
  </script>

  <!-- Sidebar filter to focus list -->
  <script>
  (function () {
    function getFocusFromQuery() {
      const q = new URLSearchParams(location.search).get('focus') || '';
      return q.split(',').map(s => s.trim()).filter(Boolean).map(s => s.toUpperCase());
    }
    async function getFocusFromFirestore() {
      try {
        const u = firebase.auth().currentUser;
        if (!u) return [];
        const snap = await firebase.firestore().collection('assignments')
          .where('userId', '==', u.uid).get();
        const set = new Set();
        snap.forEach(doc => (doc.data()?.siteIds || [])
          .forEach(id => set.add(String(id).toUpperCase())));
        return Array.from(set);
      } catch (e) {
        console.warn('fallback focus load failed:', e);
        return [];
      }
    }
    function whenSidebarReady(cb) {
      const root = document.getElementById('sidebar-content');
      if (!root) return;
      if (root.children.length > 0) { cb(root); return; }
      const obs = new MutationObserver((_, o) => {
        if (root.children.length > 0) { o.disconnect(); cb(root); }
      });
      obs.observe(root, { childList: true, subtree: true });
      setTimeout(() => obs.disconnect(), 10000);
    }
    function filterSidebarToIds(root, ids) {
      const wanted = new Set(ids.map(s => s.toUpperCase()));

      // Banner
      let banner = root.querySelector('.assign-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.className = 'assign-banner';
        root.prepend(banner);
      }
      banner.textContent = ids.length ? `Showing ${ids.length} assigned site(s)` : 'No assigned sites to show.';

      // Hide non-assigned rows
      const hasAnyId = (el) => {
        const t = (el.textContent || '').toUpperCase();
        for (const id of wanted) if (t.includes(id)) return true;
        return false;
      };
      const candidates = root.querySelectorAll('li, .list-item, .sidebar-row, .item, .site-row, div');
      candidates.forEach(el => {
        if (el.classList?.contains('assign-banner')) return;
        const keep = hasAnyId(el) || [...el.querySelectorAll('*')].some(hasAnyId);
        el.style.display = keep ? '' : 'none';
      });
      root.querySelectorAll('details').forEach(d => {
        const any = [...d.querySelectorAll('li, .list-item, .sidebar-row, .item, .site-row')]
          .some(el => el.style.display !== 'none');
        d.style.display = any ? '' : 'none';
        if (any) d.open = true;
      });
    }

    // Expand / collapse all groups
    document.getElementById('toggle-all')?.addEventListener('click', (e)=>{
      const root = document.getElementById('sidebar-content');
      const all = [...root.querySelectorAll('details')];
      const anyOpen = all.some(d => d.open);
      all.forEach(d => d.open = !anyOpen);
      e.target.textContent = anyOpen ? 'Expand All' : 'Collapse All';
    });

    firebase.auth().onAuthStateChanged(async () => {
      let ids = getFocusFromQuery();
      if (!ids.length) ids = await getFocusFromFirestore();
      if (!ids.length) return;
      whenSidebarReady(root => filterSidebarToIds(root, ids));
    });
  })();
  </script>

  <!-- Buttons + optimistic progress; persist via work_logs; also read work_logs on load -->
  <script>
  (function () {
    const db   = firebase.firestore();
    const auth = firebase.auth();
    const params = new URLSearchParams(location.search);

    let assignmentId = params.get('task') || localStorage.getItem('currentTaskId') || null;
    if (assignmentId) { try { localStorage.setItem('currentTaskId', assignmentId); } catch(_) {} }

    async function ensureTaskId(){
      if (assignmentId) return assignmentId;
      const q = (params.get('focus')||'').split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
      if (!q.length) return null;
      try{
        const batch = q.slice(0,10);
        const snap = await db.collection('assignments').where('siteIds','array-contains-any',batch).get();
        let best=null,score=-1;
        snap.forEach(doc=>{
          const arr=(doc.data().siteIds||[]).map(x=>String(x).toUpperCase());
          const sc=q.reduce((n,id)=>n+(arr.includes(id)?1:0),0);
          if(sc>score){best=doc.id;score=sc;}
        });
        if(best){ assignmentId=best; try{localStorage.setItem('currentTaskId',best);}catch(_){} }
      }catch(e){ /* not critical */ }
      return assignmentId;
    }

    const idRx = /\bM\d{3,5}\b/i;
    const up   = (s) => String(s||'').toUpperCase();
    const rootEl = () => document.getElementById('sidebar-content') || document;

    function matchIdFromNode(n){
      if (!n) return null;
      const m = (n.textContent||'').toUpperCase().match(idRx);
      return m ? m[0] : null;
    }
    function findSiteIdForNotes(input){
      if (input.dataset.siteId) return up(input.dataset.siteId);
      let el = input.closest('[data-site-id], li, .list-item, .sidebar-row, .item, div');
      for (let hops=0; el && hops<6; hops++, el=el.parentElement){
        if (el.dataset && el.dataset.siteId){ input.dataset.siteId = up(el.dataset.siteId); return input.dataset.siteId; }
        let m = matchIdFromNode(el); if (m){ input.dataset.siteId = m; return m; }
        const sum = el.querySelector && el.querySelector('summary');
        m = matchIdFromNode(sum); if (m){ input.dataset.siteId = m; return m; }
        let p = el.previousElementSibling;
        while (p){
          m = matchIdFromNode(p);
          if (m){ input.dataset.siteId = m; return m; }
          p = p.previousElementSibling;
        }
      }
      const any = matchIdFromNode(document);
      if (any) input.dataset.siteId = any;
      return any || null;
    }

    function hideAssignedChips(container){
      container.querySelectorAll('.mini-pill,.badge,.tag,.status').forEach(n=>n.style.display='none');
    }

    // ---- EFFECTIVE STATE = perSite (when readable) + freshest work_logs ----
    let perSiteCache = {};      // from assignments (if readable)
    const latestFromLogs = {};  // sid -> {status, note, _t}

    function effectiveFor(sid){
      const base = perSiteCache[sid] || {};
      const log  = latestFromLogs[sid] || {};
      const pick = {};
      pick.status = (log.status || base.status || '').toLowerCase();
      pick.note   = (log.note   != null ? log.note   : base.note) || '';
      return pick;
    }

    async function writeProgress(siteId, status, note){
      const uid = auth.currentUser?.uid || null;
      const taskId = await ensureTaskId();

      // LOG (operators always allowed by your rules)
      await db.collection('work_logs').add({
        assignmentId: taskId || null,
        siteId, status,
        note: (note||'').trim(),
        operatorUid: uid,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });

      // Optional mirror into assignments for admins only (kept commented)
      /*
      try {
        const u = auth.currentUser;
        const userSnap = await db.collection('users').doc(u.uid).get();
        const role = userSnap.data()?.role || '';
        if (role === 'admin') {
          const update = {};
          update[`perSite.${siteId}.status`]      = status;
          update[`perSite.${siteId}.note`]        = (note||'').trim();
          update[`perSite.${siteId}.operatorUid`] = u.uid;
          update[`perSite.${siteId}.updatedAt`]   = firebase.firestore.FieldValue.serverTimestamp();
          update[`perSite.${siteId}.completedAt`] = (status==='completed')
                                                    ? firebase.firestore.FieldValue.serverTimestamp()
                                                    : null;
          const tid = await ensureTaskId();
          if (tid) await db.collection('assignments').doc(tid).set(update,{merge:true});
        }
      } catch {}
      */
    }

    // ---------- injection & sync ----------
    const siteButtons = new Map(); // siteId -> button
    const siteInputs  = new Map(); // siteId -> notes input

    // optimistic state (keep UI sticky until listeners refresh)
    const optimistic = new Map();  // siteId -> {status, t}
    const OPT_TTL_MS = 20000;

    const setBtnUI = (btn, isDone) => {
      btn.classList.toggle('done', !!isDone);
      btn.textContent = isDone ? 'Undo' : 'Mark done';
    };
    const optSet = (sid, status) => optimistic.set(sid, { status, t: Date.now() });
    const optGet = (sid) => {
      const o = optimistic.get(sid);
      if (o && (Date.now() - o.t) < OPT_TTL_MS) return o;
      if (o) optimistic.delete(sid);
      return null;
    };

    function injectButtons(){
      const now  = Date.now();
      for (const [sid, o] of optimistic) if (now - o.t > OPT_TTL_MS) optimistic.delete(sid);

      const root = rootEl();
      const notes = root.querySelectorAll('input[placeholder^="Notes"], input[placeholder="Notes..."], textarea[placeholder^="Notes"]');
      notes.forEach(input=>{
        const sid = findSiteIdForNotes(input);
        if (!sid) return;

        siteInputs.set(sid, input);

        let btn = siteButtons.get(sid);
        if (!btn || btn.dataset.siteId !== sid){
          if (btn && btn.parentElement) btn.parentElement.removeChild(btn);

          btn = document.createElement('button');
          btn.type='button';
          btn.className='bs-done-btn';
          btn.dataset.siteId = sid;
          btn.textContent='Mark done';
          input.insertAdjacentElement('afterend', btn);
          siteButtons.set(sid, btn);

          btn.addEventListener('click', async (e)=>{
            e.preventDefault(); e.stopPropagation();
            const willBeDone = !btn.classList.contains('done');

            // optimistic state + UI first
            optSet(sid, willBeDone ? 'completed' : 'in_progress');
            setBtnUI(btn, willBeDone);

            try{
              await writeProgress(sid, willBeDone ? 'completed' : 'in_progress', input.value||'');
            }catch(err){
              // rollback only on unexpected failures
              optimistic.delete(sid);
              setBtnUI(btn, !willBeDone);
              console.error('Save failed:', err);
            }
          });

          const saveNote = async () => {
            const opt = optGet(sid);
            const eff = opt ? opt.status : effectiveFor(sid).status || (btn.classList.contains('done') ? 'completed' : 'in_progress');
            try{ await writeProgress(sid, eff, input.value||''); }catch(e){ console.error(e); }
          };
          input.addEventListener('change', saveNote);
          input.addEventListener('blur',   saveNote);
        }

        // reflect EFFECTIVE state -> UI (optimistic overrides freshest logs while fresh)
        const eff = effectiveFor(sid);
        const opt  = optGet(sid);
        const status = (opt?.status || eff.status || '').toLowerCase();
        const isDone = status === 'completed';
        setBtnUI(btn, isDone);

        if (typeof eff.note === 'string' && document.activeElement !== input && input.value !== eff.note) {
          input.value = eff.note;
        }

        hideAssignedChips(input.closest('li, .list-item, .sidebar-row, .item, div') || root);
      });
    }

    // run once, then keep tidy for a minute (in case the sidebar renders incrementally)
    const iv = setInterval(()=>requestAnimationFrame(injectButtons), 1000);
    setTimeout(()=>clearInterval(iv), 60000);
    requestAnimationFrame(injectButtons);

    // live snapshot of assignments (if readable) — optional
    firebase.auth().onAuthStateChanged(async ()=>{
      const tid = await ensureTaskId();
      if (tid){
        db.collection('assignments').doc(tid).onSnapshot(
          (snap)=>{
            perSiteCache = (snap.data()||{}).perSite || {};
            requestAnimationFrame(injectButtons);
          },
          ()=>{ /* operators might not have read; that's OK */ }
        );
      }
    });

    // live listeners for work_logs (read only current operator's logs to satisfy rules)
    firebase.auth().onAuthStateChanged(async (u)=>{
      if (!u) return;
      const uid = u.uid;

      // work out which site IDs are shown
      const params = new URLSearchParams(location.search);
      let ids = (params.get('focus')||'')
        .split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
      if (!ids.length) {
        const tid = await ensureTaskId();
        if (tid) {
          try {
            const s = await firebase.firestore().collection('assignments').doc(tid).get();
            ids = (s.data()?.siteIds || []).map(x=>String(x).toUpperCase());
          } catch {}
        }
      }
      const wanted = new Set(ids);

      // IMPORTANT: this query matches your rules (operatorUid == request.auth.uid)
      firebase.firestore().collection('work_logs')
        .where('operatorUid','==', uid)
        .onSnapshot((snap)=>{
          snap.docChanges().forEach(ch=>{
            const w = ch.doc.data() || {};
            const sid = String(w.siteId||'').toUpperCase();
            if (!wanted.has(sid)) return;
            const t = (w.timestamp?.toMillis?.() ?? w.completedAt?.toMillis?.() ?? w.updatedAt?.toMillis?.() ?? 0);
            const cur = latestFromLogs[sid];
            if (!cur || t > (cur._t||0)){
              latestFromLogs[sid] = {
                status:(w.status||'').toLowerCase(),
                note:  (w.note||'').trim(),
                _t:    t
              };
            }
          });
          requestAnimationFrame(injectButtons);
        }, (err)=>{
          console.warn('work_logs listener error:', err);
        });
    });
  })();
  </script>

  <script>
/* --- Lean-map helpers: viewport culling + assigned-only filter --- */
(function () {
  // Try to find the Leaflet map object your init code created
  const map =
    window.BS_MAP || window.__BS_map || window.map || (window.leafletMap || null);
  if (!map || !window.L) return; // nothing to do until the map exists

  // Parse focus (assigned) IDs from the URL: ?focus=M0123,M0456
  const up = (s) => String(s || "").trim().toUpperCase();
  const focus = new URLSearchParams(location.search).get("focus") || "";
  const FOCUS_SET = new Set(
    focus.split(",").map(up).filter(Boolean)
  );

  // How we decide if a Marker belongs to an assigned ID.
  // We look for an M#### token in the marker's title or the icon's label text.
  const idRx = /\bM\d{3,5}\b/i;
  function markerSiteId(m) {
    // 1) explicit property used by your code (if present)
    if (m && m.options && m.options.siteId) return up(m.options.siteId);
    // 2) Leaflet title/tooltip text
    if (m && typeof m.getTooltip === "function" && m.getTooltip()) {
      const t = m.getTooltip().getContent();
      const mm = String(t || "").toUpperCase().match(idRx);
      if (mm) return mm[0];
    }
    if (m && m.options && m.options.title) {
      const mm = String(m.options.title || "").toUpperCase().match(idRx);
      if (mm) return mm[0];
    }
    // 3) The DOM label inside the marker icon (your white tag)
    const txt = (m && m._icon && m._icon.textContent) ? m._icon.textContent : "";
    const mm = String(txt || "").toUpperCase().match(idRx);
    return mm ? mm[0] : null;
  }

  // Toggle a marker's visibility without removing it from the map
  function setMarkerVisible(m, on) {
    const icon = m._icon, shadow = m._shadow;
    if (icon)  icon.style.display  = on ? "" : "none";
    if (shadow) shadow.style.display = on ? "" : "none";
  }

  // We run this after every pan/zoom (debounced) to keep only what's needed on-screen.
  let rafId = 0;
  function refreshCulling() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      const padBounds = map.getBounds().pad(0.2); // a little buffer so edges don't flicker

      // Iterate all Leaflet layers the simple way; only adjust Markers (your tags)
      for (const k in map._layers) {
        const layer = map._layers[k];

        // Only handle plain L.Marker (the white ID tags)
        if (layer instanceof L.Marker) {
          const inView = padBounds.contains(layer.getLatLng());
          // If we have a focus list, hide anything not assigned, regardless of inView
          if (FOCUS_SET.size) {
            const sid = markerSiteId(layer);
            const isAssigned = !!(sid && FOCUS_SET.has(up(sid)));
            setMarkerVisible(layer, inView && isAssigned);
          } else {
            setMarkerVisible(layer, inView);
          }
        }
      }
    });
  }

  // Hook map events
  map.on("moveend zoomend", refreshCulling);

  // Initial pass (after the current frame so icons exist)
  setTimeout(refreshCulling, 0);

  // If your layer content streams in over a few seconds, keep things tidy briefly:
  const tidyUntil = Date.now() + 8000; // 8s after page load
  const iv = setInterval(() => {
    refreshCulling();
    if (Date.now() > tidyUntil) clearInterval(iv);
  }, 600);

  // Optional: expose a manual refresh for debugging
  window.BS_refreshCulling = refreshCulling;
})();
</script>

  <!-- Add this button in the sidebar (where your other buttons live). If you already have a control block, put it near “Expand All”. -->
<script>
(function injectLockButton(){
  const side = document.getElementById('sidebar');
  if (!side) return;

  // Insert the button just under the “Expand All” button
  const anchor = document.getElementById('toggle-all');
  const btn = document.createElement('button');
  btn.id = 'lock-assigned-btn';
  btn.textContent = 'Lock to assigned area';
  btn.style.margin = '0 12px 8px';   // match your spacing
  btn.style.width  = 'calc(100% - 24px)';
  btn.style.background = 'var(--accent)';
  btn.addEventListener('click', () => {
    if (window.__BS_lockAssigned?.locked) {
      window.__BS_lockAssigned.unlock();
    } else {
      window.__BS_lockAssigned.lock();
    }
  });

  if (anchor && anchor.parentNode) {
    anchor.insertAdjacentElement('afterend', btn);
  } else {
    // fallback: append near top
    const wrap = document.createElement('div');
    wrap.style.padding = '10px 12px 0';
    wrap.appendChild(btn);
    side.insertBefore(wrap, side.children[1] || null);
  }
})();
</script>

<!-- Lock-to-assignment logic -->
<script>
(function lockToAssignedArea(){
  const map =
    window.BS_MAP || window.__BS_map || window.map || (window.leafletMap || null);
  if (!map || !window.L) return;

  const up = (s) => String(s || '').trim().toUpperCase();
  const idRx = /\bM\d{3,5}\b/i;

  // Read focus list from URL
  const focusQ = new URLSearchParams(location.search).get('focus') || '';
  const FOCUS_SET = new Set(focusQ.split(',').map(up).filter(Boolean));

  // Helper: try to read an ID from a Marker (matches your white tags)
  function markerSiteId(m) {
    if (!m) return null;
    if (m.options && m.options.siteId) return up(m.options.siteId);
    if (typeof m.getTooltip === 'function' && m.getTooltip()) {
      const t = m.getTooltip().getContent();
      const mm = String(t || '').toUpperCase().match(idRx);
      if (mm) return mm[0];
    }
    if (m.options && m.options.title) {
      const mm = String(m.options.title || '').toUpperCase().match(idRx);
      if (mm) return mm[0];
    }
    const txt = (m._icon && m._icon.textContent) ? m._icon.textContent : '';
    const mm = String(txt || '').toUpperCase().match(idRx);
    return mm ? mm[0] : null;
  }

  function assignedBounds() {
    let b = null;
    for (const k in map._layers) {
      const lyr = map._layers[k];
      if (!(lyr instanceof L.Marker)) continue;
      const sid = markerSiteId(lyr);
      if (!sid || (FOCUS_SET.size && !FOCUS_SET.has(sid))) continue;
      b = b ? b.extend(lyr.getLatLng()) : L.latLngBounds(lyr.getLatLng(), lyr.getLatLng());
    }
    return b;
  }

  let locked = false;
  let lastBounds = null;

  function updateButton() {
    const btn = document.getElementById('lock-assigned-btn');
    if (!btn) return;
    btn.textContent = locked ? 'Unlock map area' : 'Lock to assigned area';
  }

  function lock() {
    const b = assignedBounds();
    if (!b) {               // markers may not be ready yet—try again shortly
      setTimeout(lock, 500);
      return;
    }
    lastBounds = b.pad(0.15);     // small margin so panning feels natural
    map.setMaxBounds(lastBounds);
    map.options.maxBoundsViscosity = 1.0;  // “sticky” at the edge
    // Fit once (don’t snap again if user already moved)
    try { map.fitBounds(lastBounds, { padding:[24,24] }); } catch(e) {}
    locked = true;
    updateButton();
    // Remember preference this session
    try { sessionStorage.setItem('bs_lock_assigned', '1'); } catch(_){}
  }

  function unlock() {
    map.setMaxBounds(null);
    map.options.maxBounds = null;
    map.options.maxBoundsViscosity = 0;
    locked = false;
    updateButton();
    try { sessionStorage.removeItem('bs_lock_assigned'); } catch(_){}
  }

  // If focus is present, auto-lock once the markers are likely on the map
  const shouldAutoLock = FOCUS_SET.size > 0;
  if (shouldAutoLock || sessionStorage.getItem('bs_lock_assigned') === '1') {
    // try a few times in case markers stream in
    let attempts = 0;
    const iv = setInterval(() => {
      attempts++;
      const b = assignedBounds();
      if (b || attempts >= 20) { // ~10s max
        clearInterval(iv);
        lock();
      }
    }, 500);
  }

  // Expose for the button click
  window.__BS_lockAssigned = { lock, unlock, get locked(){ return locked; } };

  // If markers are added dynamically later, keep bounds generous but don’t auto-jump
  let rafId = 0;
  function maybeExpandBoundsOnNewMarkers() {
    if (!locked || !lastBounds) return;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      const b = assignedBounds();
      if (b && !lastBounds.contains(b)) {
        lastBounds = b.pad(0.15);
        map.setMaxBounds(lastBounds);
      }
    });
  }
  // cheap listener: run a few seconds as layers arrive
  const tidyUntil = Date.now() + 8000;
  const tidier = setInterval(() => {
    maybeExpandBoundsOnNewMarkers();
    if (Date.now() > tidyUntil) clearInterval(tidier);
  }, 600);
})();
</script>

</body>
</html>
