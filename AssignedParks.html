<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Assigned Parks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="logo.png" type="image/png" />

  <!-- Core styles (same as ParksMowing) -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Sidebar styles (same as ParksMowing) -->
  <link rel="stylesheet" href="sidebar.css" />

  <style>
    :root{
      --ink:#0f172a; --muted:#e5e7eb; --card:#ffffff;
      --accent:#d11e2b; --accent-600:#b71a24;
      --soft:#f8fafc; --soft-2:#f1f5f9;
    }
    #map { height: 100vh; }

    /* Sidebar compact + brand */
    #sidebar{
      width: 340px;
      max-width: 86vw;
      background:#fff;
      border-right:1px solid var(--muted);
      box-shadow:0 8px 26px rgba(16,24,40,.08);
      overflow:auto;
    }
    #sidebar .sidebar-head{
      position: sticky; top:0; z-index: 5;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      color:#fff; font-weight:800;
      background: linear-gradient(90deg, var(--accent), #eb4550);
      border-bottom:1px solid rgba(255,255,255,.15);
    }
    #sidebar .sidebar-head img{ height:24px; width:auto; display:block }
    #sidebar .sidebar-head .title{ font-size:14px; letter-spacing:.3px }

    /* Buttons inside sidebar */
    #sidebar button{
      border:0; border-radius:10px; padding:8px 10px; font-weight:800; cursor:pointer; background: var(--accent); color:#fff;
    }
    #sidebar #toggle-all{ display:block; width:calc(100% - 24px); margin:10px 12px 8px; background:var(--accent); }
    #sidebar #toggle-all:hover{ background:var(--accent-600); }

    /* Full-width utility buttons (Home/Admin etc.) */
    #sidebar .wide-btn{
      display:block; width:calc(100% - 24px); margin:8px 12px;
      background:#111827; color:#fff;
    }
    #sidebar .wide-btn:hover{ background:#0b1220; }

    /* Sidebar content spacing */
    #sidebar #sidebar-content{ padding:8px 12px 16px; }

    /* Groups / details look compact */
    #sidebar-content details{
      border:1px solid var(--muted); border-radius:12px; overflow:hidden;
      background:#fff; margin-bottom:8px;
    }
    #sidebar-content details > summary{
      list-style:none; cursor:pointer; user-select:none;
      padding:8px 10px; background:var(--soft-2);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:700; color:var(--ink);
    }
    #sidebar-content details[open] > summary{ background:#eef2f7; }

    /* Rows/items inside groups (support many structures) */
    #sidebar-content li,
    #sidebar-content .list-item,
    #sidebar-content .sidebar-row,
    #sidebar-content .item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px; border-top:1px solid #eef2f7; background:#fff;
      font-weight:600; color:#111827;
    }
    #sidebar-content li:first-child{ border-top:0; }

    /* Hide "assigned" badges/chips */
    #sidebar-content .mini-pill,
    #sidebar-content .badge,
    #sidebar-content .tag,
    #sidebar-content .status { display:none !important; }

    /* Done button style */
    .bs-done-btn{
      appearance:none; border-radius:10px; border:1px solid #e2e8f0;
      background:#fff; color:#111827; padding:6px 10px; font-weight:800; cursor:pointer;
      margin-top:6px;
    }
    .bs-done-btn.done{
      background:#dcfce7; border-color:#bbf7d0; color:#065f46;
    }

    /* Banner above filtered list */
    .assign-banner{
      padding:8px 10px; margin:6px 0; border:1px solid #e2e8f0; background:#fff8f8;
      color:#7f1d1d; border-radius:8px; font-weight:700;
    }
  </style>
</head>
<body>

  <!-- Firebase + auth guard -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <script src="firebase-init.js"></script>
  <script src="auth-guard.js"></script>

  <!-- Sidebar toggle -->
  <button id="sidebar-toggle">â˜°</button>

  <!-- Sidebar -->
  <div id="sidebar">
    <div class="sidebar-head">
      <img src="logo.png" alt="Bayside" onerror="this.style.display='none'">
      <div class="title">Assigned Parks</div>
    </div>

    <!-- Return home -->
    <button class="wide-btn" id="homeBtn" type="button" title="Back to Dashboard">Return home</button>

    <button id="toggle-all">Collapse All</button>
    <div id="sidebar-content"></div>

    <div style="padding:6px 0 14px">
      <button class="wide-btn" onclick="adminLogin()">Admin Login</button>
      <div id="admin-tools" style="display:none; margin-top:6px; padding:0 12px; display:grid; gap:6px">
        <button onclick="exportPDFCouncil()" style="background:#111827">PDF report for Council</button>
        <button onclick="exportPDFBayside()" style="background:#111827">PDF Report for Bayside</button>
        <button onclick="clearUserData()" style="background:#64748b">Clear All User Data</button>
        <button onclick="showToday()" style="background:#64748b">Show Completed Today</button>
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
  (function(){
  if (!window.L) return;

  const params = new URLSearchParams(location.search);
  if (params.get('unlock') === '1') return;                    // escape hatch
  const wanted = new Set((params.get('focus')||'')
                  .split(',').map(s=>s.trim().toUpperCase()).filter(Boolean));
  if (!wanted.size) return;

  const up=s=>String(s||'').toUpperCase();
  const idRx=/\bM\d{3,5}\b/;

  function siteIdFromMarker(m){
    if (m?.options?.siteId) return up(m.options.siteId);
    if (m?.options?.title){ const mm=up(m.options.title).match(idRx); if(mm) return mm[0]; }
    if (typeof m?.getTooltip==='function' && m.getTooltip()){
      const mm=up(m.getTooltip().getContent()).match(idRx); if(mm) return mm[0];
    }
    const txt=(m?._icon?.textContent)?up(m._icon.textContent):'';
    const mm=txt.match(idRx); return mm?mm[0]:null;
  }

  const state=new Map(); // mapId -> {bounds, matched, fitted, started}
  function maybeFit(map){
    const s=state.get(map._leaflet_id); if(!s||s.fitted) return;
    const min=Math.min(3, wanted.size);
    if (s.matched>=min || Date.now()-s.started>15000){
      if (s.bounds){
        const lock=s.bounds.pad(0.25);
        try{ map.fitBounds(lock,{padding:[24,24]}); }catch{}
        map.setMaxBounds(lock);
        map.options.maxBoundsViscosity=1.0;
        map.setMinZoom(map.getZoom());                   // stops zooming out to whole region
      }
      s.fitted=true;
    }
  }

  const origAddTo=L.Marker.prototype.addTo;
  L.Marker.prototype.addTo=function(map){
    const res=origAddTo.call(this,map);
    const sid=siteIdFromMarker(this);
    if(sid && wanted.has(sid)){
      let s=state.get(map._leaflet_id);
      if(!s){ s={bounds:null,matched:0,fitted:false,started:Date.now()}; state.set(map._leaflet_id,s); }
      const ll=this.getLatLng();
      if(ll){ s.bounds=s.bounds? s.bounds.extend(ll):L.latLngBounds(ll,ll); s.matched++; maybeFit(map); }
    }
    return res;
  };

  // Safety sweep in case some markers were present before the patch loaded
  setTimeout(()=>{
    const maps=[];
    ['BS_MAP','__BS_map','map','leafletMap'].forEach(k=>{ if(window[k]?.fitBounds) maps.push(window[k]); });
    maps.forEach(map=>{
      let s=state.get(map._leaflet_id);
      if(!s){ s={bounds:null,matched:0,fitted:false,started:Date.now()-14000}; state.set(map._leaflet_id,s); }
      for(const k in map._layers){
        const lyr=map._layers[k];
        if(!(lyr instanceof L.Marker)) continue;
        const sid=siteIdFromMarker(lyr);
        if(sid && wanted.has(sid)){
          const ll=lyr.getLatLng();
          s.bounds=s.bounds? s.bounds.extend(ll):L.latLngBounds(ll,ll);
          s.matched++;
        }
      }
      maybeFit(map);
    });
  },1000);
  </script>

  <!-- Sidebar filter to focus list -->
  <script>
  (function () {
    function getFocusFromQuery() {
      const q = new URLSearchParams(location.search).get('focus') || '';
      return q.split(',').map(s => s.trim()).filter(Boolean).map(s => s.toUpperCase());
    }
    async function getFocusFromFirestore() {
      try {
        const u = firebase.auth().currentUser;
        if (!u) return [];
        const snap = await firebase.firestore().collection('assignments')
          .where('userId', '==', u.uid).get();
        const set = new Set();
        snap.forEach(doc => (doc.data()?.siteIds || [])
          .forEach(id => set.add(String(id).toUpperCase())));
        return Array.from(set);
      } catch (e) {
        console.warn('fallback focus load failed:', e);
        return [];
      }
    }
    function whenSidebarReady(cb) {
      const root = document.getElementById('sidebar-content');
      if (!root) return;
      if (root.children.length > 0) { cb(root); return; }
      const obs = new MutationObserver((_, o) => {
        if (root.children.length > 0) { o.disconnect(); cb(root); }
      });
      obs.observe(root, { childList: true, subtree: true });
      setTimeout(() => obs.disconnect(), 10000);
    }
    function filterSidebarToIds(root, ids) {
      const wanted = new Set(ids.map(s => s.toUpperCase()));

      // Banner
      let banner = root.querySelector('.assign-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.className = 'assign-banner';
        root.prepend(banner);
      }
      banner.textContent = ids.length ? `Showing ${ids.length} assigned site(s)` : 'No assigned sites to show.';

      // Hide non-assigned rows
      const hasAnyId = (el) => {
        const t = (el.textContent || '').toUpperCase();
        for (const id of wanted) if (t.includes(id)) return true;
        return false;
      };
      const candidates = root.querySelectorAll('li, .list-item, .sidebar-row, .item, .site-row, div');
      candidates.forEach(el => {
        if (el.classList?.contains('assign-banner')) return;
        const keep = hasAnyId(el) || [...el.querySelectorAll('*')].some(hasAnyId);
        el.style.display = keep ? '' : 'none';
      });
      root.querySelectorAll('details').forEach(d => {
        const any = [...d.querySelectorAll('li, .list-item, .sidebar-row, .item, .site-row')]
          .some(el => el.style.display !== 'none');
        d.style.display = any ? '' : 'none';
        if (any) d.open = true;
      });
    }

    // Expand / collapse all groups
    document.getElementById('toggle-all')?.addEventListener('click', (e)=>{
      const root = document.getElementById('sidebar-content');
      const all = [...root.querySelectorAll('details')];
      const anyOpen = all.some(d => d.open);
      all.forEach(d => d.open = !anyOpen);
      e.target.textContent = anyOpen ? 'Expand All' : 'Collapse All';
    });

    firebase.auth().onAuthStateChanged(async () => {
      let ids = getFocusFromQuery();
      if (!ids.length) ids = await getFocusFromFirestore();
      if (!ids.length) return;
      whenSidebarReady(root => filterSidebarToIds(root, ids));
    });
  })();
  </script>

  <!-- Buttons + optimistic progress; persist via work_logs; also read work_logs on load -->
  <script>
  (function () {
    const db   = firebase.firestore();
    const auth = firebase.auth();
    const params = new URLSearchParams(location.search);

    let assignmentId = params.get('task') || localStorage.getItem('currentTaskId') || null;
    if (assignmentId) { try { localStorage.setItem('currentTaskId', assignmentId); } catch(_) {} }

    async function ensureTaskId(){
      if (assignmentId) return assignmentId;
      const q = (params.get('focus')||'').split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
      if (!q.length) return null;
      try{
        const batch = q.slice(0,10);
        const snap = await db.collection('assignments').where('siteIds','array-contains-any',batch).get();
        let best=null,score=-1;
        snap.forEach(doc=>{
          const arr=(doc.data().siteIds||[]).map(x=>String(x).toUpperCase());
          const sc=q.reduce((n,id)=>n+(arr.includes(id)?1:0),0);
          if(sc>score){best=doc.id;score=sc;}
        });
        if(best){ assignmentId=best; try{localStorage.setItem('currentTaskId',best);}catch(_){} }
      }catch(e){ /* not critical */ }
      return assignmentId;
    }

    const idRx = /\bM\d{3,5}\b/i;
    const up   = (s) => String(s||'').toUpperCase();
    const rootEl = () => document.getElementById('sidebar-content') || document;

    function matchIdFromNode(n){
      if (!n) return null;
      const m = (n.textContent||'').toUpperCase().match(idRx);
      return m ? m[0] : null;
    }
    function findSiteIdForNotes(input){
      if (input.dataset.siteId) return up(input.dataset.siteId);
      let el = input.closest('[data-site-id], li, .list-item, .sidebar-row, .item, div');
      for (let hops=0; el && hops<6; hops++, el=el.parentElement){
        if (el.dataset && el.dataset.siteId){ input.dataset.siteId = up(el.dataset.siteId); return input.dataset.siteId; }
        let m = matchIdFromNode(el); if (m){ input.dataset.siteId = m; return m; }
        const sum = el.querySelector && el.querySelector('summary');
        m = matchIdFromNode(sum); if (m){ input.dataset.siteId = m; return m; }
        let p = el.previousElementSibling;
        while (p){
          m = matchIdFromNode(p);
          if (m){ input.dataset.siteId = m; return m; }
          p = p.previousElementSibling;
        }
      }
      const any = matchIdFromNode(document);
      if (any) input.dataset.siteId = any;
      return any || null;
    }

    function hideAssignedChips(container){
      container.querySelectorAll('.mini-pill,.badge,.tag,.status').forEach(n=>n.style.display='none');
    }

    // ---- EFFECTIVE STATE = perSite (when readable) + freshest work_logs ----
    let perSiteCache = {};      // from assignments (if readable)
    const latestFromLogs = {};  // sid -> {status, note, _t}

    function effectiveFor(sid){
      const base = perSiteCache[sid] || {};
      const log  = latestFromLogs[sid] || {};
      const pick = {};
      pick.status = (log.status || base.status || '').toLowerCase();
      pick.note   = (log.note   != null ? log.note   : base.note) || '';
      return pick;
    }

    async function writeProgress(siteId, status, note){
      const uid = auth.currentUser?.uid || null;
      const taskId = await ensureTaskId();

      await db.collection('work_logs').add({
        assignmentId: taskId || null,
        siteId, status,
        note: (note||'').trim(),
        operatorUid: uid,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });
    }

    // ---------- injection & sync ----------
    const siteButtons = new Map(); // siteId -> button
    const siteInputs  = new Map(); // siteId -> notes input

    // optimistic state (keep UI sticky until listeners refresh)
    const optimistic = new Map();  // siteId -> {status, t}
    const OPT_TTL_MS = 20000;

    const setBtnUI = (btn, isDone) => {
      btn.classList.toggle('done', !!isDone);
      btn.textContent = isDone ? 'Undo' : 'Mark done';
    };
    const optSet = (sid, status) => optimistic.set(sid, { status, t: Date.now() });
    const optGet = (sid) => {
      const o = optimistic.get(sid);
      if (o && (Date.now() - o.t) < OPT_TTL_MS) return o;
      if (o) optimistic.delete(sid);
      return null;
    };

    function injectButtons(){
      const now  = Date.now();
      for (const [sid, o] of optimistic) if (now - o.t > OPT_TTL_MS) optimistic.delete(sid);

      const root = rootEl();
      const notes = root.querySelectorAll('input[placeholder^="Notes"], input[placeholder="Notes..."], textarea[placeholder^="Notes"]');
      notes.forEach(input=>{
        const sid = findSiteIdForNotes(input);
        if (!sid) return;

        siteInputs.set(sid, input);

        let btn = siteButtons.get(sid);
        if (!btn || btn.dataset.siteId !== sid){
          if (btn && btn.parentElement) btn.parentElement.removeChild(btn);

          btn = document.createElement('button');
          btn.type='button';
          btn.className='bs-done-btn';
          btn.dataset.siteId = sid;
          btn.textContent='Mark done';
          input.insertAdjacentElement('afterend', btn);
          siteButtons.set(sid, btn);

          btn.addEventListener('click', async (e)=>{
            e.preventDefault(); e.stopPropagation();
            const willBeDone = !btn.classList.contains('done');

            // optimistic state + UI first
            optSet(sid, willBeDone ? 'completed' : 'in_progress');
            setBtnUI(btn, willBeDone);

            try{
              await writeProgress(sid, willBeDone ? 'completed' : 'in_progress', input.value||'');
            }catch(err){
              optimistic.delete(sid);
              setBtnUI(btn, !willBeDone);
              console.error('Save failed:', err);
            }
          });

          const saveNote = async () => {
            const opt = optGet(sid);
            const eff = opt ? opt.status : effectiveFor(sid).status || (btn.classList.contains('done') ? 'completed' : 'in_progress');
            try{ await writeProgress(sid, eff, input.value||''); }catch(e){ console.error(e); }
          };
          input.addEventListener('change', saveNote);
          input.addEventListener('blur',   saveNote);
        }

        const eff = effectiveFor(sid);
        const opt  = optGet(sid);
        const status = (opt?.status || eff.status || '').toLowerCase();
        const isDone = status === 'completed';
        setBtnUI(btn, isDone);

        if (typeof eff.note === 'string' && document.activeElement !== input && input.value !== eff.note) {
          input.value = eff.note;
        }

        hideAssignedChips(input.closest('li, .list-item, .sidebar-row, .item, div') || root);
      });
    }

    const iv = setInterval(()=>requestAnimationFrame(injectButtons), 1000);
    setTimeout(()=>clearInterval(iv), 60000);
    requestAnimationFrame(injectButtons);

    // live snapshot of assignments (if readable) â€” optional
    firebase.auth().onAuthStateChanged(async ()=>{
      const tid = await ensureTaskId();
      if (tid){
        db.collection('assignments').doc(tid).onSnapshot(
          (snap)=>{
            perSiteCache = (snap.data()||{}).perSite || {};
            requestAnimationFrame(injectButtons);
          },
          ()=>{}
        );
      }
    });

    // live listeners for work_logs (only current operator's logs)
    firebase.auth().onAuthStateChanged(async (u)=>{
      if (!u) return;
      const uid = u.uid;

      const params = new URLSearchParams(location.search);
      let ids = (params.get('focus')||'')
        .split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
      if (!ids.length) {
        const tid = await ensureTaskId();
        if (tid) {
          try {
            const s = await firebase.firestore().collection('assignments').doc(tid).get();
            ids = (s.data()?.siteIds || []).map(x=>String(x).toUpperCase());
          } catch {}
        }
      }
      const wanted = new Set(ids);

      firebase.firestore().collection('work_logs')
        .where('operatorUid','==', uid)
        .onSnapshot((snap)=>{
          snap.docChanges().forEach(ch=>{
            const w = ch.doc.data() || {};
            const sid = String(w.siteId||'').toUpperCase();
            if (!wanted.has(sid)) return;
            const t = (w.timestamp?.toMillis?.() ?? w.completedAt?.toMillis?.() ?? w.updatedAt?.toMillis?.() ?? 0);
            const cur = latestFromLogs[sid];
            if (!cur || t > (cur._t||0)){
              latestFromLogs[sid] = {
                status:(w.status||'').toLowerCase(),
                note:  (w.note||'').trim(),
                _t:    t
              };
            }
          });
          requestAnimationFrame(injectButtons);
        }, (err)=>{
          console.warn('work_logs listener error:', err);
        });
    });
  })();
  </script>

  <!-- Lean map: cull off-screen markers and hide non-assigned tags -->
  <script>
  (function () {
    function getMap() {
      return (window.BS && window.BS.map) ||
             window.BS_MAP || window.__BS_map ||
             window.leafletMap || window.map || null;
    }
    const map = getMap();
    if (!map || !window.L) return;

    const up = (s) => String(s || "").trim().toUpperCase();
    const focus = new URLSearchParams(location.search).get("focus") || "";
    const FOCUS_SET = new Set(focus.split(",").map(up).filter(Boolean));
    const idRx = /\bM\d{3,5}\b/i;

    function markerSiteId(m) {
      if (m && m.options && m.options.siteId) return up(m.options.siteId);
      if (m && typeof m.getTooltip === "function" && m.getTooltip()) {
        const t = m.getTooltip().getContent();
        const mm = String(t || "").toUpperCase().match(idRx);
        if (mm) return mm[0];
      }
      if (m && m.options && m.options.title) {
        const mm = String(m.options.title || "").toUpperCase().match(idRx);
        if (mm) return mm[0];
      }
      const txt = (m && m._icon && m._icon.textContent) ? m._icon.textContent : "";
      const mm = String(txt || "").toUpperCase().match(idRx);
      return mm ? mm[0] : null;
    }
    function setMarkerVisible(m, on) {
      const icon = m._icon, shadow = m._shadow;
      if (icon)  icon.style.display  = on ? "" : "none";
      if (shadow) shadow.style.display = on ? "" : "none";
    }

    let rafId = 0;
    function refreshCulling() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        const padBounds = map.getBounds().pad(0.2);
        for (const k in map._layers) {
          const layer = map._layers[k];
          if (layer instanceof L.Marker) {
            const inView = padBounds.contains(layer.getLatLng());
            if (FOCUS_SET.size) {
              const sid = markerSiteId(layer);
              const isAssigned = !!(sid && FOCUS_SET.has(up(sid)));
              setMarkerVisible(layer, inView && isAssigned);
            } else {
              setMarkerVisible(layer, inView);
            }
          }
        }
      });
    }
    map.on("moveend zoomend", refreshCulling);
    setTimeout(refreshCulling, 0);
    const tidyUntil = Date.now() + 8000;
    const iv = setInterval(() => {
      refreshCulling();
      if (Date.now() > tidyUntil) clearInterval(iv);
    }, 600);
    window.BS_refreshCulling = refreshCulling;
  })();
  </script>

<script>
/* Auto fit+lock to ?focus=... as markers are added (race-proof) */
(function(){
  if (!window.L) return;

  const params = new URLSearchParams(location.search);
  if (params.get('unlock') === '1') return;               // escape hatch
  const wanted = new Set((params.get('focus')||'')
                  .split(',').map(s=>s.trim().toUpperCase()).filter(Boolean));
  if (!wanted.size) return;

  const up = s => String(s||'').toUpperCase();
  const idRx = /\bM\d{3,5}\b/;

  function siteIdFromMarker(m){
    if (m && m.options && m.options.siteId) return up(m.options.siteId);
    if (m && m.options && m.options.title){
      const mm = up(m.options.title).match(idRx); if (mm) return mm[0];
    }
    if (m && typeof m.getTooltip==='function' && m.getTooltip()){
      const mm = up(m.getTooltip().getContent()).match(idRx); if (mm) return mm[0];
    }
    const txt = (m && m._icon && m._icon.textContent) ? up(m._icon.textContent) : '';
    const mm = txt.match(idRx); return mm ? mm[0] : null;
  }

  // Per-map state: we may not know your map variable; use the map passed to addTo()
  const state = new Map(); // map._leaflet_id -> {bounds, matched, fitted, started}

  function maybeFit(map){
    const s = state.get(map._leaflet_id);
    if (!s || s.fitted) return;
    const min = Math.min(3, wanted.size);                 // fit after a few matches
    if (s.matched >= min || Date.now() - s.started > 15000){
      if (s.bounds){
        const lock = s.bounds.pad(0.25);
        try { map.fitBounds(lock, { padding:[24,24] }); } catch {}
        map.setMaxBounds(lock);
        map.options.maxBoundsViscosity = 1.0;
        map.setMinZoom(map.getZoom());                    // donâ€™t allow zooming out to the whole LGA
      }
      s.fitted = true;
    }
  }

  const origAddTo = L.Marker.prototype.addTo;
  L.Marker.prototype.addTo = function(map){
    const res = origAddTo.call(this, map);
    const sid = siteIdFromMarker(this);
    if (sid && wanted.has(sid)){
      let s = state.get(map._leaflet_id);
      if (!s){ s = { bounds:null, matched:0, fitted:false, started:Date.now() }; state.set(map._leaflet_id, s); }
      const ll = this.getLatLng();
      if (ll){
        s.bounds = s.bounds ? s.bounds.extend(ll) : L.latLngBounds(ll, ll);
        s.matched++;
        maybeFit(map);
      }
    }
    return res;
  };

  // Safety: do one sweep a bit later in case some markers existed before this patch loaded
  setTimeout(()=>{
    const maps = [];
    ['BS_MAP','__BS_map','map','leafletMap'].forEach(k => { if (window[k] && window[k].fitBounds) maps.push(window[k]); });
    maps.forEach(map=>{
      let s = state.get(map._leaflet_id);
      if (!s){ s = { bounds:null, matched:0, fitted:false, started:Date.now()-14000 }; state.set(map._leaflet_id, s); }
      for (const k in map._layers){
        const lyr = map._layers[k];
        if (!(lyr instanceof L.Marker)) continue;
        const sid = siteIdFromMarker(lyr);
        if (sid && wanted.has(sid)){
          const ll = lyr.getLatLng();
          s.bounds = s.bounds ? s.bounds.extend(ll) : L.latLngBounds(ll,ll);
          s.matched++;
        }
      }
      maybeFit(map);
    });
  }, 1000);
})();
</script>


</body>
</html>
