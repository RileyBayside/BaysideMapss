<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Assigned Parks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="logo.png" type="image/png" />

  <!-- Core styles (same as ParksMowing) -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Sidebar styles (same as ParksMowing) -->
  <link rel="stylesheet" href="sidebar.css" />

  <style>
    :root{
      --ink:#0f172a; --muted:#e5e7eb; --card:#ffffff;
      --accent:#d11e2b; --accent-600:#b71a24;
      --soft:#f8fafc; --soft-2:#f1f5f9;
    }
    #map { height: 100vh; }

    /* Sidebar compact + brand */
    #sidebar{
      width: 340px;
      max-width: 86vw;
      background:#fff;
      border-right:1px solid var(--muted);
      box-shadow:0 8px 26px rgba(16,24,40,.08);
      overflow:auto;
    }
    #sidebar .sidebar-head{
      position: sticky; top:0; z-index: 5;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      color:#fff; font-weight:800;
      background: linear-gradient(90deg, var(--accent), #eb4550);
      border-bottom:1px solid rgba(255,255,255,.15);
    }
    #sidebar .sidebar-head img{ height:24px; width:auto; display:block }
    #sidebar .sidebar-head .title{ font-size:14px; letter-spacing:.3px }

    /* Buttons inside sidebar */
    #sidebar button{
      border:0; border-radius:10px; padding:8px 10px; font-weight:800; cursor:pointer; background: var(--accent); color:#fff;
    }
    #sidebar #toggle-all{ display:block; width:calc(100% - 24px); margin:10px 12px 8px; background:var(--accent); }
    #sidebar #toggle-all:hover{ background:var(--accent-600); }

    /* Sidebar content spacing */
    #sidebar #sidebar-content{ padding:8px 12px 16px; }

    /* Groups / details look compact */
    #sidebar-content details{
      border:1px solid var(--muted); border-radius:12px; overflow:hidden;
      background:#fff; margin-bottom:8px;
    }
    #sidebar-content details > summary{
      list-style:none; cursor:pointer; user-select:none;
      padding:8px 10px; background:var(--soft-2);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:700; color:var(--ink);
    }
    #sidebar-content details[open] > summary{ background:#eef2f7; }

    /* Rows/items inside groups (support many structures) */
    #sidebar-content li,
    #sidebar-content .list-item,
    #sidebar-content .sidebar-row,
    #sidebar-content .item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px; border-top:1px solid #eef2f7; background:#fff;
      font-weight:600; color:#111827;
    }
    #sidebar-content li:first-child{ border-top:0; }

    /* Hide "assigned" badges/chips */
    #sidebar-content .mini-pill,
    #sidebar-content .badge,
    #sidebar-content .tag,
    #sidebar-content .status { display:none !important; }

    /* Our single Done button style */
    .bs-done-btn{
      appearance:none; border-radius:10px; border:1px solid #e2e8f0;
      background:#fff; color:#111827; padding:6px 10px; font-weight:800; cursor:pointer;
      margin-top:6px;
    }
    .bs-done-btn.done{
      background:#dcfce7; border-color:#bbf7d0; color:#065f46;
    }

    /* Banner above filtered list */
    .assign-banner{
      padding:8px 10px; margin:6px 0; border:1px solid #e2e8f0; background:#fff8f8;
      color:#7f1d1d; border-radius:8px; font-weight:700;
    }
  </style>
</head>
<body>

  <!-- Firebase + auth guard -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <script src="firebase-init.js"></script>
  <script src="auth-guard.js"></script>

  <!-- Sidebar toggle -->
  <button id="sidebar-toggle">â˜°</button>

  <!-- Sidebar -->
  <div id="sidebar">
    <div class="sidebar-head">
      <img src="logo.png" alt="Bayside" onerror="this.style.display='none'">
      <div class="title">Assigned Parks</div>
    </div>

    <button id="toggle-all">Collapse All</button>
    <div id="sidebar-content"></div>

    <div style="padding:10px 12px 16px">
      <button onclick="adminLogin()">Admin Login</button>
      <div id="admin-tools" style="display:none; margin-top:8px; display:grid; gap:6px">
        <button onclick="exportPDFCouncil()" style="background:#111827">PDF report for Council</button>
        <button onclick="exportPDFBayside()" style="background:#111827">PDF Report for Bayside</button>
        <button onclick="clearUserData()" style="background:#64748b">Clear All User Data</button>
        <button onclick="showToday()" style="background:#64748b">Show Completed Today</button>
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Try to suppress double-init from shared map bootstrap -->
  <script>window.BS_DISABLE_AUTO_INIT = true;</script>
  <script src="script.js"></script>
  <script src="sidebar.js"></script>
  <script>
    (function(){
      // Fallback init only if not already initialised by script.js
      try{
        var mapDiv = document.getElementById('map');
        if (typeof window.initParksMowingMap === 'function' && mapDiv && !mapDiv._leaflet_id){
          window.initParksMowingMap();
        }
      }catch(e){ /* cosmetic if it fails */ }
    })();
  </script>

  <!-- Sidebar filter to focus list -->
  <script>
  (function () {
    function getFocusFromQuery() {
      const q = new URLSearchParams(location.search).get('focus') || '';
      return q.split(',').map(s => s.trim()).filter(Boolean).map(s => s.toUpperCase());
    }
    async function getFocusFromFirestore() {
      try {
        const u = firebase.auth().currentUser;
        if (!u) return [];
        const snap = await firebase.firestore().collection('assignments')
          .where('userId', '==', u.uid).get();
        const set = new Set();
        snap.forEach(doc => (doc.data()?.siteIds || [])
          .forEach(id => set.add(String(id).toUpperCase())));
        return Array.from(set);
      } catch (e) {
        console.warn('fallback focus load failed:', e);
        return [];
      }
    }
    function whenSidebarReady(cb) {
      const root = document.getElementById('sidebar-content');
      if (!root) return;
      if (root.children.length > 0) { cb(root); return; }
      const obs = new MutationObserver((_, o) => {
        if (root.children.length > 0) { o.disconnect(); cb(root); }
      });
      obs.observe(root, { childList: true, subtree: true });
      setTimeout(() => obs.disconnect(), 10000);
    }
    function filterSidebarToIds(root, ids) {
      const wanted = new Set(ids.map(s => s.toUpperCase()));

      // Banner
      let banner = root.querySelector('.assign-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.className = 'assign-banner';
        root.prepend(banner);
      }
      banner.textContent = ids.length ? `Showing ${ids.length} assigned site(s)` : 'No assigned sites to show.';

      // Hide non-assigned rows
      const hasAnyId = (el) => {
        const t = (el.textContent || '').toUpperCase();
        for (const id of wanted) if (t.includes(id)) return true;
        return false;
      };
      const candidates = root.querySelectorAll('li, .list-item, .sidebar-row, .item, .site-row, div');
      candidates.forEach(el => {
        if (el.classList?.contains('assign-banner')) return;
        const keep = hasAnyId(el) || [...el.querySelectorAll('*')].some(hasAnyId);
        el.style.display = keep ? '' : 'none';
      });
      root.querySelectorAll('details').forEach(d => {
        const any = [...d.querySelectorAll('li, .list-item, .sidebar-row, .item, .site-row')]
          .some(el => el.style.display !== 'none');
        d.style.display = any ? '' : 'none';
        if (any) d.open = true;
      });
    }

    // Expand / collapse all groups
    document.getElementById('toggle-all')?.addEventListener('click', (e)=>{
      const root = document.getElementById('sidebar-content');
      const all = [...root.querySelectorAll('details')];
      const anyOpen = all.some(d => d.open);
      all.forEach(d => d.open = !anyOpen);
      e.target.textContent = anyOpen ? 'Expand All' : 'Collapse All';
    });

    firebase.auth().onAuthStateChanged(async () => {
      let ids = getFocusFromQuery();
      if (!ids.length) ids = await getFocusFromFirestore();
      if (!ids.length) return;
      whenSidebarReady(root => filterSidebarToIds(root, ids));
    });
  })();
  </script>

  <!-- Buttons + optimistic progress; persist via work_logs; also read work_logs on load -->
  <script>
  (function () {
    const db   = firebase.firestore();
    const auth = firebase.auth();
    const params = new URLSearchParams(location.search);

    let assignmentId = params.get('task') || localStorage.getItem('currentTaskId') || null;
    if (assignmentId) { try { localStorage.setItem('currentTaskId', assignmentId); } catch(_) {} }

    async function ensureTaskId(){
      if (assignmentId) return assignmentId;
      const q = (params.get('focus')||'').split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
      if (!q.length) return null;
      try{
        const batch = q.slice(0,10);
        const snap = await db.collection('assignments').where('siteIds','array-contains-any',batch).get();
        let best=null,score=-1;
        snap.forEach(doc=>{
          const arr=(doc.data().siteIds||[]).map(x=>String(x).toUpperCase());
          const sc=q.reduce((n,id)=>n+(arr.includes(id)?1:0),0);
          if(sc>score){best=doc.id;score=sc;}
        });
        if(best){ assignmentId=best; try{localStorage.setItem('currentTaskId',best);}catch(_){} }
      }catch(e){ /* not critical */ }
      return assignmentId;
    }

    const idRx = /\bM\d{3,5}\b/i;
    const up   = (s) => String(s||'').toUpperCase();
    const rootEl = () => document.getElementById('sidebar-content') || document;

    function matchIdFromNode(n){
      if (!n) return null;
      const m = (n.textContent||'').toUpperCase().match(idRx);
      return m ? m[0] : null;
    }
    function findSiteIdForNotes(input){
      if (input.dataset.siteId) return up(input.dataset.siteId);
      let el = input.closest('[data-site-id], li, .list-item, .sidebar-row, .item, div');
      for (let hops=0; el && hops<6; hops++, el=el.parentElement){
        if (el.dataset && el.dataset.siteId){ input.dataset.siteId = up(el.dataset.siteId); return input.dataset.siteId; }
        let m = matchIdFromNode(el); if (m){ input.dataset.siteId = m; return m; }
        const sum = el.querySelector && el.querySelector('summary');
        m = matchIdFromNode(sum); if (m){ input.dataset.siteId = m; return m; }
        let p = el.previousElementSibling;
        while (p){
          m = matchIdFromNode(p);
          if (m){ input.dataset.siteId = m; return m; }
          p = p.previousElementSibling;
        }
      }
      const any = matchIdFromNode(document);
      if (any) input.dataset.siteId = any;
      return any || null;
    }

    function hideAssignedChips(container){
      container.querySelectorAll('.mini-pill,.badge,.tag,.status').forEach(n=>n.style.display='none');
    }

    // ---- EFFECTIVE STATE = perSite (when readable) + freshest work_logs ----
    let perSiteCache = {};      // from assignments (if readable)
    const latestFromLogs = {};  // sid -> {status, note, _t}

    function effectiveFor(sid){
      const base = perSiteCache[sid] || {};
      const log  = latestFromLogs[sid] || {};
      const pick = {};
      // prefer newest log values
      pick.status = (log.status || base.status || '').toLowerCase();
      pick.note   = (log.note   != null ? log.note   : base.note) || '';
      return pick;
    }

    async function writeProgress(siteId, status, note){
      const uid = auth.currentUser?.uid || null;
      const taskId = await ensureTaskId();

      // LOG (operators always allowed by your rules)
      await db.collection('work_logs').add({
        assignmentId: taskId || null,
        siteId, status,
        note: (note||'').trim(),
        operatorUid: uid,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });

      // If you want admins to also mirror into assignments, uncomment this block:
      /*
      try {
        const u = auth.currentUser;
        const userSnap = await db.collection('users').doc(u.uid).get();
        const role = userSnap.data()?.role || '';
        if (role === 'admin') {
          const update = {};
          update[`perSite.${siteId}.status`]      = status;
          update[`perSite.${siteId}.note`]        = (note||'').trim();
          update[`perSite.${siteId}.operatorUid`] = u.uid;
          update[`perSite.${siteId}.updatedAt`]   = firebase.firestore.FieldValue.serverTimestamp();
          update[`perSite.${siteId}.completedAt`] = (status==='completed')
                                                    ? firebase.firestore.FieldValue.serverTimestamp()
                                                    : null;
          const tid = await ensureTaskId();
          if (tid) await db.collection('assignments').doc(tid).set(update,{merge:true});
        }
      } catch {}
      */
    }

    // ---------- injection & sync ----------
    const siteButtons = new Map(); // siteId -> button
    const siteInputs  = new Map(); // siteId -> notes input

    // optimistic state (keep UI sticky until listeners refresh)
    const optimistic = new Map();  // siteId -> {status, t}
    const OPT_TTL_MS = 20000;

    const setBtnUI = (btn, isDone) => {
      btn.classList.toggle('done', !!isDone);
      btn.textContent = isDone ? 'Undo' : 'Mark done';
    };
    const optSet = (sid, status) => optimistic.set(sid, { status, t: Date.now() });
    const optGet = (sid) => {
      const o = optimistic.get(sid);
      if (o && (Date.now() - o.t) < OPT_TTL_MS) return o;
      if (o) optimistic.delete(sid);
      return null;
    };

    function injectButtons(){
      const now  = Date.now();
      for (const [sid, o] of optimistic) if (now - o.t > OPT_TTL_MS) optimistic.delete(sid);

      const root = rootEl();
      const notes = root.querySelectorAll('input[placeholder^="Notes"], input[placeholder="Notes..."], textarea[placeholder^="Notes"]');
      notes.forEach(input=>{
        const sid = findSiteIdForNotes(input);
        if (!sid) return;

        siteInputs.set(sid, input);

        let btn = siteButtons.get(sid);
        if (!btn || btn.dataset.siteId !== sid){
          if (btn && btn.parentElement) btn.parentElement.removeChild(btn);

          btn = document.createElement('button');
          btn.type='button';
          btn.className='bs-done-btn';
          btn.dataset.siteId = sid;
          btn.textContent='Mark done';
          input.insertAdjacentElement('afterend', btn);
          siteButtons.set(sid, btn);

          btn.addEventListener('click', async (e)=>{
            e.preventDefault(); e.stopPropagation();
            const willBeDone = !btn.classList.contains('done');

            // optimistic state + UI first
            optSet(sid, willBeDone ? 'completed' : 'in_progress');
            setBtnUI(btn, willBeDone);

            try{
              await writeProgress(sid, willBeDone ? 'completed' : 'in_progress', input.value||'');
            }catch(err){
              // rollback only on unexpected failures
              optimistic.delete(sid);
              setBtnUI(btn, !willBeDone);
              console.error('Save failed:', err);
            }
          });

          const saveNote = async () => {
            const opt = optGet(sid);
            const eff = opt ? opt.status : effectiveFor(sid).status || (btn.classList.contains('done') ? 'completed' : 'in_progress');
            try{ await writeProgress(sid, eff, input.value||''); }catch(e){ console.error(e); }
          };
          input.addEventListener('change', saveNote);
          input.addEventListener('blur',   saveNote);
        }

        // reflect EFFECTIVE state -> UI (optimistic overrides freshest logs while fresh)
        const eff = effectiveFor(sid);
        const opt  = optGet(sid);
        const status = (opt?.status || eff.status || '').toLowerCase();
        const isDone = status === 'completed';
        setBtnUI(btn, isDone);

        if (typeof eff.note === 'string' && document.activeElement !== input && input.value !== eff.note) {
          input.value = eff.note;
        }

        hideAssignedChips(input.closest('li, .list-item, .sidebar-row, .item, div') || root);
      });
    }

    // run once, then keep tidy for a minute (in case the sidebar renders incrementally)
    const iv = setInterval(()=>requestAnimationFrame(injectButtons), 1000);
    setTimeout(()=>clearInterval(iv), 60000);
    requestAnimationFrame(injectButtons);

    // live snapshot of assignments (if readable) â€” optional
    firebase.auth().onAuthStateChanged(async ()=>{
      const tid = await ensureTaskId();
      if (tid){
        db.collection('assignments').doc(tid).onSnapshot(
          (snap)=>{
            perSiteCache = (snap.data()||{}).perSite || {};
            requestAnimationFrame(injectButtons);
          },
          ()=>{ /* operators might not have read; that's OK */ }
        );
      }
    });

    // live listeners for work_logs for the visible site ids (drives persistence)
    firebase.auth().onAuthStateChanged(async ()=>{
      // figure out which site IDs are on the page
      const focus = (params.get('focus')||'').split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
      let ids = focus;
      if (!ids.length){
        // best-effort: fetch from assignment if readable
        const tid = await ensureTaskId();
        if (tid){
          try{
            const s = await db.collection('assignments').doc(tid).get();
            ids = (s.data()?.siteIds || []).map(x=>String(x).toUpperCase());
          }catch{}
        }
      }
      ids = Array.from(new Set(ids));
      if (!ids.length) return;

      const step = 10;
      for(let i=0;i<ids.length;i+=step){
        const batch = ids.slice(i,i+step);
        db.collection('work_logs').where('siteId','in',batch).onSnapshot((snap)=>{
          snap.docChanges().forEach(ch=>{
            const w = ch.doc.data() || {};
            const sid = String(w.siteId||'').toUpperCase();
            const t = (w.timestamp?.toMillis?.() ?? w.completedAt?.toMillis?.() ?? w.updatedAt?.toMillis?.() ?? 0);
            const cur = latestFromLogs[sid];
            if (!cur || t > (cur._t||0)){
              latestFromLogs[sid] = {
                status: (w.status||'').toLowerCase(),
                note:   (w.note||'').trim(),
                _t: t
              };
            }
          });
          requestAnimationFrame(injectButtons);
        });
      }
    });
  })();
  </script>

</body>
</html>
